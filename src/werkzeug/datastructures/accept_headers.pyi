from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Union

from .structures import ImmutableList

class Accept(ImmutableList[Tuple[str, int]]):
    provided: bool
    def __init__(
        self, values: Optional[Union[Accept, Iterable[Tuple[str, float]]]] = None
    ) -> None: ...
    def _specificity(self, value: str) -> Tuple[bool, ...]: ...
    def _value_matches(self, value: str, item: str) -> bool: ...
    @overload  # type: ignore
    def __getitem__(self, key: str) -> int: ...
    @overload
    def __getitem__(self, key: int) -> Tuple[str, int]: ...
    @overload
    def __getitem__(self, key: slice) -> Iterable[Tuple[str, int]]: ...
    def quality(self, key: str) -> int: ...
    def __contains__(self, value: str) -> bool: ...  # type: ignore
    def index(self, key: str) -> int: ...  # type: ignore
    def find(self, key: str) -> int: ...
    def values(self) -> Iterator[str]: ...
    def to_header(self) -> str: ...
    def _best_single_match(self, match: str) -> Optional[Tuple[str, int]]: ...
    def best_match(
        self, matches: Iterable[str], default: Optional[str] = None
    ) -> Optional[str]: ...
    @property
    def best(self) -> str: ...

def _normalize_mime(value: str) -> List[str]: ...

class MIMEAccept(Accept):
    def _specificity(self, value: str) -> Tuple[bool, ...]: ...
    def _value_matches(self, value: str, item: str) -> bool: ...
    @property
    def accept_html(self) -> bool: ...
    @property
    def accept_xhtml(self) -> bool: ...
    @property
    def accept_json(self) -> bool: ...

def _normalize_lang(value: str) -> List[str]: ...

class LanguageAccept(Accept):
    def _value_matches(self, value: str, item: str) -> bool: ...
    def best_match(
        self, matches: Iterable[str], default: Optional[str] = None
    ) -> Optional[str]: ...

class CharsetAccept(Accept):
    def _value_matches(self, value: str, item: str) -> bool: ...
