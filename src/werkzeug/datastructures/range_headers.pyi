from datetime import datetime
from typing import Callable
from typing import List
from typing import Optional
from typing import Tuple

class IfRange:
    etag: Optional[str]
    date: Optional[datetime]
    def __init__(
        self, etag: Optional[str] = None, date: Optional[datetime] = None
    ) -> None: ...
    def to_header(self) -> str: ...

class Range:
    units: str
    ranges: List[Tuple[int, Optional[int]]]
    def __init__(self, units: str, ranges: List[Tuple[int, Optional[int]]]) -> None: ...
    def range_for_length(self, length: Optional[int]) -> Optional[Tuple[int, int]]: ...
    def make_content_range(self, length: Optional[int]) -> Optional[ContentRange]: ...
    def to_header(self) -> str: ...
    def to_content_range_header(self, length: Optional[int]) -> Optional[str]: ...

def _callback_property(name: str) -> property: ...

class ContentRange:
    on_update: Optional[Callable[[ContentRange], None]]
    def __init__(
        self,
        units: Optional[str],
        start: Optional[int],
        stop: Optional[int],
        length: Optional[int] = None,
        on_update: Optional[Callable[[ContentRange], None]] = None,
    ) -> None: ...
    @property
    def units(self) -> Optional[str]: ...
    @units.setter
    def units(self, value: Optional[str]) -> None: ...
    @property
    def start(self) -> Optional[int]: ...
    @start.setter
    def start(self, value: Optional[int]) -> None: ...
    @property
    def stop(self) -> Optional[int]: ...
    @stop.setter
    def stop(self, value: Optional[int]) -> None: ...
    @property
    def length(self) -> Optional[int]: ...
    @length.setter
    def length(self, value: Optional[int]) -> None: ...
    def set(
        self,
        start: Optional[int],
        stop: Optional[int],
        length: Optional[int] = None,
        units: Optional[str] = "bytes",
    ) -> None: ...
    def unset(self) -> None: ...
    def to_header(self) -> str: ...
